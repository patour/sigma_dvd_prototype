# Grid Partitioning Module

## Overview

The `GridPartitioner` module provides spatial partitioning capabilities for power grids generated by `generate_power_grid`. It divides a power grid into P balanced regions using geometric k-means clustering, identifies separator nodes on partition boundaries, and creates logical isolation between partitions **without modifying the graph structure**.

## Key Features

- **Geometric k-means clustering**: Uses node (x, y) coordinates for spatial partitioning
- **Load balancing**: Ensures each partition has similar number of load nodes (within configurable tolerance)
- **Separator nodes**: Automatically identifies boundary nodes between partitions
- **Graph preservation**: **No edges are removed** - graph topology is fully preserved
- **Connectivity awareness**: Reports connectivity status of interior nodes; may have disconnected regions if they contain loads
- **Constraints enforcement**:
  - Separator nodes contain no loads
  - Pad nodes remain global (not assigned to partitions)
  - Interior nodes without loads that are disconnected are promoted to separators

## Important Limitations

⚠️ **Interior Connectivity**: Due to the geometric nature of k-means clustering, partitions may contain disconnected interior regions, especially when those regions include load nodes. The partitioner will:
- Promote disconnected non-load nodes to separators (when possible)
- Keep disconnected components that contain loads (cannot separate loads)
- Report connectivity status via `get_partition_connectivity_info()`

For applications requiring fully connected partitions, consider:
- Using different partition counts (P values)
- Trying different random seeds
- Post-processing to merge small disconnected components

## Usage

### Basic Example

```python
from generate_power_grid import generate_power_grid
from irdrop import GridPartitioner

# Generate a power grid
G, loads, pads = generate_power_grid(
    K=3, N0=16, I_N=100, N_vsrc=8,
    max_stripe_res=5.0, max_via_res=0.1,
    load_current=1.0, seed=42, plot=False
)

# Create partitioner
partitioner = GridPartitioner(G, loads, pads, seed=42)

# Partition into 4 regions with 15% load balance tolerance
result = partitioner.partition(P=4, balance_tolerance=0.15)

# Print results
print(result)
# Output: PartitionResult(P=4, loads=[25, 25, 25, 25], 
#         separators=[14, 78, 32, 30], balance_ratio=1.000, boundary_edges=290)

# Access partition details
for partition in result.partitions:
    print(f"Partition {partition.partition_id}: "
          f"{partition.num_loads} loads, "
          f"{len(partition.separator_nodes)} separators")
```

### Visualization

```python
# Visualize the partitioned grid
fig, ax = partitioner.visualize_partitions(result, figsize=(12, 10), show=True)

# Or save without displaying
fig, ax = partitioner.visualize_partitions(result, show=False)
fig.savefig("partitions.png", dpi=150)
```

### Advanced Options

```python
# Restrict separators to specific layers (e.g., only layer 0)
result = partitioner.partition(
    P=4, 
    balance_tolerance=0.12,              # Stricter balance requirement (12%)
    separator_layer_threshold=0,         # Only layer-0 nodes can be separators
    max_iterations=150                   # More k-means iterations
)
```

## API Reference

### GridPartitioner

**Constructor:**
```python
GridPartitioner(graph, load_nodes, pad_nodes, seed=None)
```

**Parameters:**
- `graph` (nx.Graph): NetworkX graph from `generate_power_grid`
- `load_nodes` (Dict): Dictionary mapping load nodes to their currents
- `pad_nodes` (List): List of pad (Vdd) nodes
- `seed` (int, optional): Random seed for reproducibility

**Methods:**

#### partition()
```python
partition(P, max_iterations=100, balance_tolerance=0.15, separator_layer_threshold=None)
```

Partition the grid into P spatial regions.

**Parameters:**
- `P` (int): Number of desired partitions
- `max_iterations` (int): Maximum k-means iterations (default: 100)
- `balance_tolerance` (float): Maximum allowed load imbalance (default: 0.15 = 15%)
- `separator_layer_threshold` (int, optional): If specified, only nodes on layers ≤ threshold can be separators

**Returns:** `PartitionResult` object

**Raises:**
- `ValueError`: If P ≤ 0 or P > number of load nodes

#### visualize_partitions()
```python
visualize_partitions(result, figsize=(10, 8), show=True)
```

Visualize the partitioned grid with color-coded regions.

**Parameters:**
- `result` (PartitionResult): Result from `partition()`
- `figsize` (tuple): Figure size (width, height)
- `show` (bool): If True, call `plt.show()` (default: True)

**Returns:** `(fig, ax)` tuple

### PartitionResult

Dataclass containing partitioning results.

**Attributes:**
- `partitions` (List[Partition]): List of Partition objects
- `separator_nodes` (Set): All separator nodes across all partitions
- `boundary_edges` (List[Tuple]): Edges connected to separator nodes (u, v, edge_data)
- `load_balance_ratio` (float): max(loads) / min(loads) across partitions

**Properties:**
- `num_partitions` (int): Number of partitions

**Methods:**
- `get_partition(partition_id)`: Get Partition by ID

### Partition

Dataclass representing a single partition.

**Attributes:**
- `partition_id` (int): Unique identifier
- `interior_nodes` (Set): Nodes fully within partition (not on boundary)
- `separator_nodes` (Set): Nodes on partition boundary
- `load_nodes` (Set): Load nodes within this partition

**Properties:**
- `all_nodes` (Set): Union of interior_nodes and separator_nodes
- `num_loads` (int): Number of load nodes

## Algorithm Details

### 1. K-Means Clustering with Load Balancing

The partitioner uses a modified k-means algorithm that operates on node (x, y) coordinates:

1. **Initialization**: K-means++ for initial cluster centers
2. **Assignment**: Assign each node to nearest cluster center
3. **Balance check**: If load distribution violates tolerance, reassign nodes
4. **Update**: Recalculate cluster centers
5. **Iterate**: Repeat until convergence or max_iterations reached

### 2. Separator Identification

A node becomes a separator if:
- It has edges to nodes in different partitions, AND
- It is not a load node, AND
- It is not a pad node, AND
- (If `separator_layer_threshold` specified) Its layer ≤ threshold

### 3. Connectivity Refinement

After initial separator identification, the algorithm verifies that interior nodes within each partition can reach each other without traversing separators:
- For each partition, performs BFS from one interior node
- Identifies unreachable interior nodes
- Non-load unreachable nodes become additional separators
- Load nodes that are unreachable trigger a warning (they remain in the partition but may be isolated)

### 4. Boundary Edge Identification

All edges with at least one endpoint being a separator are marked as boundary edges. These edges define the logical boundaries between partitions, but **are not removed** from the graph.

## Performance Characteristics

- **Time Complexity**: O(N·P·K) where N=nodes, P=partitions, K=iterations
- **Space Complexity**: O(N)
- **Typical Runtime**: ~0.5s for 500-node grid with P=4

## Constraints and Limitations

1. **Minimum partitions**: Cannot create more partitions than load nodes
2. **Balance tolerance**: Very strict tolerances (<5%) may not converge for some grids
3. **Graph preservation**: The input graph is **NOT modified** - edges are preserved
4. **Layer restriction**: If `separator_layer_threshold=0`, high-layer connectivity may be lost
5. **Unreachable loads**: Some loads may become isolated within a partition if separator placement creates disconnected regions (warning issued)

## Best Practices

1. **Use fresh graphs**: Create a new graph for each partitioning attempt since the operation modifies edges
2. **Reasonable P values**: For 100 loads, P ∈ [2, 10] typically works well
3. **Balance vs. separation**: Higher P → more removed edges → better isolation but harder balancing
4. **Reproducibility**: Always set `seed` for deterministic results

## Example: Comparing Partition Counts

```python
for P in [2, 3, 4, 6]:
    # Create fresh grid for each test
    G, loads, pads = generate_power_grid(K=3, N0=16, I_N=100, N_vsrc=8,
                                         max_stripe_res=5.0, max_via_res=0.1,
                                         seed=42, plot=False)
    
    partitioner = GridPartitioner(G, loads, pads, seed=42)
    result = partitioner.partition(P=P)
    
    load_counts = [p.num_loads for p in result.partitions]
    print(f"P={P}: loads={load_counts}, balance={result.load_balance_ratio:.3f}")

# Output:
# P=2: loads=[47, 53], balance=1.128
# P=3: loads=[32, 34, 34], balance=1.062
# P=4: loads=[25, 25, 25, 25], balance=1.000
# P=6: loads=[16, 17, 17, 16, 17, 17], balance=1.062
```

## Integration with IR-Drop Analysis

Partitioning enables hierarchical or parallel IR-drop analysis:

```python
# 1. Partition the grid
partitioner = GridPartitioner(G, loads, pads, seed=42)
result = partitioner.partition(P=4)

# 2. Analyze each partition independently
from irdrop import PowerGridModel, IRDropSolver, StimulusGenerator

for partition in result.partitions:
    # Extract subgraph for this partition
    partition_nodes = partition.all_nodes | set(pads)  # Include pads
    G_sub = G.subgraph(partition_nodes).copy()
    
    # Create model and solve
    model = PowerGridModel(G_sub, pad_nodes=pads, vdd=1.0)
    
    # Generate stimulus only for loads in this partition
    stim_gen = StimulusGenerator(list(partition.load_nodes), vdd=1.0)
    meta = stim_gen.generate(total_power=1.0, percent=0.5)
    
    solver = IRDropSolver(model)
    result_ir = solver.solve(meta.currents, meta)
    
    print(f"Partition {partition.partition_id}: "
          f"min_voltage={min(result_ir.voltages.values()):.4f}V")
```

## Testing

Comprehensive test suite available in `tests/test_partitioner.py`:

```bash
python3 -m unittest tests.test_partitioner -v
```

Tests verify:
- Load balance within tolerance
- No inter-partition edges
- Separator constraints
- Reproducibility
- Edge cases (invalid P, zero partitions, etc.)

## See Also

- `generate_power_grid.py`: Grid generation
- `example_partitioning.py`: Standalone example
- `proto.ipynb`: Interactive notebook examples
