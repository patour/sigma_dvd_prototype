# Static IR-Drop Analysis Modules

This prototype adds modular utilities for performing static IR-drop analysis on the artificial power grid generated by `generate_power_grid.py`.

## Components

- `irdrop/power_grid_model.py` – Builds sparse conductance matrix (Laplacian) and reduced system with pad (voltage source) nodes treated as Dirichlet boundary conditions.
- `irdrop/stimulus.py` – Generates current sink stimuli (node -> current) from total power with uniform or Gaussian distribution over selected load nodes.
- `irdrop/solver.py` – High-level orchestration for single and batch solves; returns voltages and IR-drop values.
- `irdrop/grid_partitioner.py` – Structured vertical slab partitioning (deterministic); k-means legacy path removed.
- `irdrop/effective_resistance.py` – Compute effective resistance between node pairs or from nodes to ground.
- `example_ir_drop.py` – IR-drop analysis demonstration script.
- `example_partitioning.py` – Grid partitioning demonstration script.

## Installation

Create (or activate) an environment and install dependencies:

```csh
pip install -r requirements.txt
```

## Usage Example

```python
from generate_power_grid import generate_power_grid
from irdrop import PowerGridModel, StimulusGenerator, IRDropSolver

G, loads, pads = generate_power_grid(K=3, N0=12, I_N=150, N_vsrc=4,
                                     max_stripe_res=1.0, max_via_res=0.1,
                                     load_current=1.0, seed=7, plot=False)

model = PowerGridModel(G, pad_nodes=pads, vdd=1.0)
stim_gen = StimulusGenerator(load_nodes=list(loads.keys()), vdd=1.0, seed=42)

# Single stimulus (30% of load nodes, Gaussian distribution)
meta = stim_gen.generate(total_power=1.2, percent=0.30, distribution="gaussian")
solver = IRDropSolver(model)
result = solver.solve(meta.currents, metadata={"power": meta.total_power})
print("Min voltage:", min(result.voltages.values()))

from irdrop import plot_voltage_map, plot_ir_drop_map

# Batch stimuli
metas = stim_gen.generate_batch([0.5, 1.0, 2.0], percent=0.25, distribution="uniform")
stimuli = [m.currents for m in metas]
batch_results = solver.solve_batch(stimuli, metas)
for m, r in zip(metas, batch_results):
    summary = solver.summarize(r)
    print(f"P={m.total_power:.2f}W minV={summary['min_voltage']:.4f} maxDrop={summary['max_drop']:.4f}")

# Plot heatmaps (layer 0 example) without showing (headless) then display
voltages = batch_results[-1].voltages
plot_voltage_map(G, voltages, layer=0, show=False)
plot_ir_drop_map(G, voltages, vdd=1.0, layer=0, show=False)
```

## Concepts

Equation: \( G V = I \) where \( G \) is the nodal conductance matrix assembled from resistors (`g = 1/R`). Pads are fixed at \( V_{DD} \) and eliminated to form the reduced system.

Stimulus currents are positive for *sinks* (nodes drawing current). Internally these are converted to negative injections in the solver to match the sign convention of the nodal equation.

IR-drop per node: `Vdd - V_node`.

## Distribution Modes

- `uniform`: Equal current per selected node.
- `gaussian`: Absolute values of normal samples; normalized to the total current.

## Extensibility Ideas

- Support multiple pad voltages / multi-domain analysis.
- Add resistance temperature scaling models.
- Integrate with a visualization overlay for voltage heatmap.
- Add congestion-aware non-uniform load placement.

## Quick Run

```csh
python example_ir_drop.py

## Plotting

`plot_voltage_map(G, voltages, layer=None)` and `plot_ir_drop_map(G, voltages, vdd, layer=None)` create scatter heatmaps. Pass `show=False` to suppress GUI in batch/headless runs.

## Running Tests

```csh
python -m unittest discover -s tests -p 'test_*.py'
```

All tests validate matrix assembly, stimulus current totals, batch solve ordering, and plotting functions.
```

## License

Prototype code for internal evaluation. Adjust licensing as needed.
