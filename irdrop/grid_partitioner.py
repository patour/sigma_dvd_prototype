#!/usr/bin/env python3
"""
Grid partitioner for power grids generated by generate_power_grid (STRUCTURED ONLY).

Deterministically partitions the grid into P vertical slabs (by X coordinate of layer-0
load nodes) with near‑balanced load distribution (difference ≤ 1 load). Separators are
entire node columns at internal boundaries (excluding loads & pads). Graph topology is
never modified; separators are a logical concept only. Pads remain global.

Removed legacy k-means path (was experimental and could produce disconnected interiors).
This module now guarantees each partition's interior (excluding separators & pads) is
single-component; if not, non‑load nodes in small stray components are promoted to
separators.
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, List, Set, Tuple, Optional
import warnings
import logging

import networkx as nx
import numpy as np

logger = logging.getLogger(__name__)


@dataclass
class Partition:
    """A single partition of the grid.
    
    Attributes:
        partition_id: Unique identifier for this partition
        interior_nodes: Set of nodes fully within this partition (not separators)
        separator_nodes: Set of nodes on the boundary of this partition
        load_nodes: Set of load nodes within this partition
        all_nodes: Union of interior_nodes and separator_nodes
    """
    partition_id: int
    interior_nodes: Set
    separator_nodes: Set
    load_nodes: Set
    
    @property
    def all_nodes(self) -> Set:
        """All nodes belonging to this partition (interior + separator)."""
        return self.interior_nodes | self.separator_nodes
    
    @property
    def num_loads(self) -> int:
        """Number of load nodes in this partition."""
        return len(self.load_nodes)


@dataclass
class PartitionResult:
    """Result of grid partitioning.
    
    Attributes:
        partitions: List of Partition objects
        separator_nodes: Set of all separator nodes across all partitions
        boundary_edges: List of edges that cross partition boundaries (connect to separators)
        load_balance_ratio: max(num_loads) / min(num_loads) across partitions
        
    Note: Interior nodes within a partition may form multiple connected components if
    they contain load nodes that cannot be separated. Use get_partition_connectivity_info()
    to analyze connectivity.
    """
    partitions: List[Partition]
    separator_nodes: Set
    boundary_edges: List[Tuple]
    load_balance_ratio: float
    
    @property
    def num_partitions(self) -> int:
        """Number of partitions."""
        return len(self.partitions)
    
    def get_partition(self, partition_id: int) -> Optional[Partition]:
        """Get partition by ID."""
        for p in self.partitions:
            if p.partition_id == partition_id:
                return p
        return None
    
    def get_partition_connectivity_info(self, graph: nx.Graph, pad_nodes: Set) -> Dict:
        """Analyze connectivity of interior nodes within each partition.
        
        Args:
            graph: The power grid graph
            pad_nodes: Set of pad nodes
            
        Returns:
            Dict with partition_id -> connectivity info mapping
        """
        from collections import deque
        
        info = {}
        for partition in self.partitions:
            interior = partition.interior_nodes
            if len(interior) <= 1:
                info[partition.partition_id] = {
                    'interior_count': len(interior),
                    'connected': True,
                    'connectivity_ratio': 1.0,
                    'num_components': 1 if interior else 0
                }
                continue
            
            # BFS to find reachable nodes
            start = next(iter(interior))
            visited = {start}
            queue = deque([start])
            
            while queue:
                current = queue.popleft()
                for neighbor in graph.neighbors(current):
                    if neighbor in visited or neighbor in self.separator_nodes or neighbor in pad_nodes:
                        continue
                    if neighbor in interior:
                        visited.add(neighbor)
                        queue.append(neighbor)
            
            reachable = visited & interior
            ratio = len(reachable) / len(interior)
            
            info[partition.partition_id] = {
                'interior_count': len(interior),
                'connected': ratio == 1.0,
                'connectivity_ratio': ratio,
                'reachable_count': len(reachable),
                'unreachable_count': len(interior) - len(reachable)
            }
        
        return info
    
    def __repr__(self) -> str:
        load_counts = [p.num_loads for p in self.partitions]
        sep_counts = [len(p.separator_nodes) for p in self.partitions]
        return (f"PartitionResult(P={self.num_partitions}, "
                f"loads={load_counts}, separators={sep_counts}, "
                f"balance_ratio={self.load_balance_ratio:.3f}, "
                f"boundary_edges={len(self.boundary_edges)})")


class GridPartitioner:
    """Structured slab partitioner for power grid graphs.

    Deterministic vertical slicing based on sorted X of layer-0 load nodes.

    Args:
        graph: NetworkX graph from generate_power_grid
        load_nodes: Dict mapping load nodes to their currents
        pad_nodes: List of pad (Vdd) nodes (remain global)
        seed: Optional seed (retained for API stability; not used by structured method)
    """
    
    def __init__(
        self, 
        graph: nx.Graph, 
        load_nodes: Dict,
        pad_nodes: List,
        seed: Optional[int] = None
    ):
        self.G = graph
        self.load_nodes = set(load_nodes.keys())
        self.pad_nodes = set(pad_nodes)
        self.seed = seed
        self.rng = np.random.RandomState(seed)
        
    def partition(
        self,
        P: int,
        axis: str = 'auto',
    ) -> PartitionResult:
        """Partition the grid into P structured regions along specified axis.

        Args:
            P: Number of desired partitions (must be ≤ number of load nodes).
            axis: Partitioning axis - 'x' (vertical slabs), 'y' (horizontal slabs), 
                  or 'auto' (choose axis with better load balance).

        Returns:
            PartitionResult
        """
        if P <= 0:
            raise ValueError(f"Number of partitions must be positive, got {P}")
        if P > len(self.load_nodes):
            raise ValueError(f"Cannot create {P} partitions with only {len(self.load_nodes)} loads")
        if axis not in ('x', 'y', 'auto'):
            raise ValueError(f"axis must be 'x', 'y', or 'auto', got '{axis}'")
        
        if axis == 'x':
            return self._structured_partition_x(P)
        elif axis == 'y':
            return self._structured_partition_y(P)
        else:  # auto
            return self._select_best_axis(P)

    # ------------------------------------------------------------------
    # Structured partition methods (connectivity-guaranteed)
    # ------------------------------------------------------------------
    def _select_best_axis(self, P: int) -> PartitionResult:
        """Choose X or Y axis based on which produces better load balance.
        
        Args:
            P: Number of partitions
            
        Returns:
            PartitionResult from the axis with lower balance ratio
        """
        result_x = self._structured_partition_x(P)
        result_y = self._structured_partition_y(P)
        
        if result_x.load_balance_ratio <= result_y.load_balance_ratio:
            return result_x
        else:
            return result_y
    
    def _structured_partition_x(self, P: int) -> PartitionResult:
        """Deterministic vertical slab partitioning along X axis."""
        return self._structured_partition(P, axis='x')
    
    def _structured_partition_y(self, P: int) -> PartitionResult:
        """Deterministic horizontal slab partitioning along Y axis."""
        return self._structured_partition(P, axis='y')
    
    def _structured_partition(self, P: int, axis: str = 'x') -> PartitionResult:
        """Deterministic, connectivity-safe partitioning along specified axis.

        Strategy:
          1. Collect layer-0 load nodes and sort by coordinate (X or Y based on axis).
          2. Slice the coordinate range into P contiguous slabs so that load counts per slab
             are balanced (difference at most 1 load).
          3. Choose boundary positions from existing via columns (for layer-0 separation guarantee).
          4. All nodes (any layer) with coordinate in (coord_min, coord_max) assigned to partition interior;
             columns at coordinate == boundary become separators (excluding loads & pads).
          5. Connectivity holds because interiors are contiguous along stripes and vias.

        Args:
            P: Number of partitions
            axis: 'x' for vertical slabs (partition by X), 'y' for horizontal slabs (partition by Y)

        Returns:
            PartitionResult with guaranteed connected interiors.
        """
        coord_idx = 0 if axis == 'x' else 1  # 0=X, 1=Y
        
        # Gather load nodes (layer 0 only by construction) with coordinates
        load_nodes_with_xy = [
            (n, self.G.nodes[n]["xy"][0], self.G.nodes[n]["xy"][1]) for n in self.load_nodes
        ]
        # Sort by chosen axis coordinate
        load_nodes_with_xy.sort(key=lambda t: t[coord_idx + 1])  # t[1]=x, t[2]=y
        total_loads = len(load_nodes_with_xy)
        # Compute ideal counts per partition
        base = total_loads // P
        extras = total_loads % P  # first 'extras' partitions get one extra load
        counts = [base + (1 if i < extras else 0) for i in range(P)]
        # Determine indices where we cut
        boundaries_idx = []
        acc = 0
        for c in counts[:-1]:  # last partition ends at end
            acc += c
            boundaries_idx.append(acc)
        # Convert indices to boundary positions (between adjacent load nodes)
        load_coords = [t[coord_idx + 1] for t in load_nodes_with_xy]
        boundary_coords = []
        for idx in boundaries_idx:
            # place boundary at existing via position nearest midpoint between idx-1 and idx
            left_coord = load_coords[idx - 1]
            right_coord = load_coords[idx]
            mid = 0.5 * (left_coord + right_coord)
            # choose via position closest to mid (ensures layer-0 separators are vias)
            boundary_coords.append(self._nearest_via_position(mid, axis))
        # Precompute node coord lookup and slab ranges over all nodes (ensure endpoints included)
        node_coord = {n: self.G.nodes[n]['xy'][coord_idx] for n in self.G.nodes()}
        coord_min_all_nodes = min(node_coord.values())
        coord_max_all_nodes = max(node_coord.values())
        slab_edges = [coord_min_all_nodes] + boundary_coords + [coord_max_all_nodes + 1e-12]

        # Build partition assignments
        partition_assignments: Dict[object, int] = {}
        separator_nodes: Set = set()

        # Mark separators: nodes at boundary positions
        # Strategy:
        #   X-axis: Layer 0 via nodes (intersection points separate vertical slabs)
        #   Y-axis: Layer 1+ nodes ONLY (horizontal layers separate perfectly, skip layer 0 entirely)
        # Filter: Exclude endpoint nodes (degree 1) - they don't separate anything
        boundary_coord_set = set(boundary_coords)
        for n, coord in node_coord.items():
            if coord not in boundary_coord_set:
                continue
            if n in self.load_nodes or n in self.pad_nodes:
                continue
            
            layer = self.G.nodes[n].get('layer', 0)
            node_kind = self.G.nodes[n].get('kind', '')
            
            if axis == 'x':
                # X-axis (vertical slabs): use layer 0 via nodes + higher layers
                # Skip endpoint nodes (degree 1) - they have only one neighbor, don't separate
                if self.G.degree(n) <= 1:
                    continue
                    
                if layer == 0 and 'via' in node_kind:
                    separator_nodes.add(n)
                elif layer > 0:
                    # Other layers: any non-load/non-pad node
                    separator_nodes.add(n)
            else:  # axis == 'y'
                # Y-axis (horizontal slabs): ONLY layer 1+ nodes
                # Skip all layer-0 nodes (including vias) - horizontal layers separate perfectly
                if layer > 0:
                    # Skip endpoint nodes at higher layers too
                    if self.G.degree(n) <= 1:
                        continue
                    separator_nodes.add(n)

        # Assign nodes to partitions by slab interval
        for n, coord in node_coord.items():
            if n in separator_nodes:
                continue
            if n in self.pad_nodes:
                continue  # pads remain global
            # Find slab index
            for p in range(P):
                if slab_edges[p] <= coord < slab_edges[p + 1]:
                    partition_assignments[n] = p
                    break

        # Ensure every non-pad node is assigned (fallback catch-all)
        for n in self.G.nodes():
            if n in self.pad_nodes:
                continue
            if n not in partition_assignments:
                coord = node_coord[n]
                for p in range(P):
                    if slab_edges[p] <= coord < slab_edges[p + 1]:
                        partition_assignments[n] = p
                        break

        # Build partitions
        partitions = self._build_partitions(partition_assignments, separator_nodes, P)

        # Assign separator nodes to adjacent partitions (logical ownership for reporting)
        for sep in list(separator_nodes):
            neighbor_partitions = {partition_assignments[nbr] for nbr in self.G.neighbors(sep) if nbr in partition_assignments}
            if neighbor_partitions:
                partition_assignments[sep] = min(neighbor_partitions)
            else:
                # fallback: assign by slab position
                coord = node_coord[sep]
                for p in range(P):
                    if slab_edges[p] <= coord < slab_edges[p + 1]:
                        partition_assignments[sep] = p
                        break
        # Ensure every separator gets an assignment (final safeguard)
        for sep in separator_nodes:
            if sep not in partition_assignments:
                partition_assignments[sep] = 0

        partitions = self._build_partitions(partition_assignments, separator_nodes, P)

        # Connectivity prioritized: verify and, if disconnected, promote offending non-load nodes to separators until connected.
        for attempt in range(10):
            all_connected = self._validate_connectivity(partitions, separator_nodes)
            if all_connected:
                break
            # Promote nodes from smaller components to separators (exclude loads)
            changed = False
            for p in partitions:
                interior = p.interior_nodes - separator_nodes - self.pad_nodes
                if len(interior) <= 1:
                    continue
                # Find components
                components = self._find_connected_components(interior, separator_nodes)
                if len(components) <= 1:
                    continue
                # Keep largest component, promote others to separators
                largest = max(components, key=len)
                for comp in components:
                    if comp is largest:
                        continue
                    # Check if this is a 2-node component with endpoint + load (unavoidable isolation)
                    if len(comp) == 2:
                        nodes_list = list(comp)
                        has_load = any(n in self.load_nodes for n in nodes_list)
                        has_endpoint = any(self.G.degree(n) <= 1 for n in nodes_list)
                        
                        if has_load and has_endpoint:
                            # This is an unavoidable isolated load-endpoint pair
                            # Keep them in interior (endpoint cannot help connectivity anyway)
                            continue
                    
                    # Promote all non-load nodes from other disconnected components to separators
                    # Respect axis-specific layer constraints:
                    #   Y-axis: only promote layer 1+ nodes (skip all layer 0)
                    #   X-axis: promote any non-load node
                    for node in comp:
                        if node in self.load_nodes:
                            # Do not reassign load nodes; preserve initial balanced distribution
                            continue
                        
                        # Y-axis connectivity enforcement: skip layer-0 nodes
                        if axis == 'y':
                            node_layer = self.G.nodes[node].get('layer', 0)
                            if node_layer == 0:
                                # Cannot use layer-0 nodes as separators for Y-axis
                                continue
                        
                        separator_nodes.add(node)
                        changed = True
            if changed:
                partitions = self._build_partitions(partition_assignments, separator_nodes, P)
            else:
                break
        else:
            logger.info("Connectivity enforcement reached iteration limit without achieving full connectivity.")
        
        # Final connectivity validation after enforcement
        # Note: Some disconnections are acceptable:
        #   - Y-axis: disconnected layer-0 components (expected with layer 1+ separators only)
        #   - Both axes: isolated load nodes surrounded by separators (unavoidable with fixed boundaries)
        final_connectivity = self._validate_connectivity(partitions, separator_nodes)
        if not final_connectivity:
            conn_info = self._get_connectivity_summary(partitions, separator_nodes)
            if conn_info['has_isolated_loads']:
                logger.debug(
                    f"{axis.upper()}-axis partition has {conn_info['num_isolated_loads']} isolated load nodes "
                    f"(surrounded by separators, acceptable limitation of structured partitioning)"
                )
            elif axis == 'y':
                logger.debug(
                    f"Y-axis partition has disconnected layer-0 components "
                    f"(expected with layer 1+ separators only)"
                )
            else:
                logger.warning(
                    f"{axis.upper()}-axis partition has unexpected disconnected components"
                )

        load_counts = [p.num_loads for p in partitions]
        balance_ratio = max(load_counts) / min(load_counts) if min(load_counts) > 0 else float("inf")
    # Guarantee separator presence: if none found (rare), synthesize one per internal boundary
        if not separator_nodes and P > 1:
            for b_coord in boundary_coords:
                # gather candidates sorted by proximity to boundary coordinate
                candidates_all = [n for n in self.G.nodes() if n not in self.load_nodes and n not in self.pad_nodes]
                candidates_all.sort(key=lambda n: abs(node_coord[n] - b_coord))
                chosen = None
                for cand in candidates_all:
                    chosen = cand
                    break
                if chosen is not None:
                    separator_nodes.add(chosen)
            partitions = self._build_partitions(partition_assignments, separator_nodes, P)
            boundary_edges = self._identify_boundary_edges(separator_nodes)
        else:
            boundary_edges = self._identify_boundary_edges(separator_nodes)
        return PartitionResult(
            partitions=partitions,
            separator_nodes=separator_nodes,
            boundary_edges=boundary_edges,
            load_balance_ratio=balance_ratio,
        )

    def _nearest_node_column(self, target_x: float) -> float:
        """Return x coordinate of existing node column closest to target_x."""
        xs = {self.G.nodes[n]["xy"][0] for n in self.G.nodes()}
        return min(xs, key=lambda xv: abs(xv - target_x))
    
    def _nearest_via_column(self, target_x: float) -> float:
        """Return x coordinate of via column closest to target_x.
        
        Via columns are x positions where via nodes exist (nodes with 'via' in kind attribute).
        Prefer via columns to ensure layer-0 separators are via nodes, not load nodes.
        """
        via_xs = {self.G.nodes[n]["xy"][0] for n in self.G.nodes() 
                  if 'via' in self.G.nodes[n].get('kind', '')}
        if not via_xs:
            # Fallback to any node column if no vias found
            return self._nearest_node_column(target_x)
        return min(via_xs, key=lambda xv: abs(xv - target_x))
    
    def _nearest_via_position(self, target_coord: float, axis: str) -> float:
        """Return coordinate of via row/column closest to target_coord along specified axis.
        
        Args:
            target_coord: Target coordinate value
            axis: 'x' for via columns (X positions), 'y' for via rows (Y positions)
        
        Returns:
            Coordinate of nearest via row/column along specified axis
        """
        coord_idx = 0 if axis == 'x' else 1
        via_coords = {self.G.nodes[n]["xy"][coord_idx] for n in self.G.nodes() 
                      if 'via' in self.G.nodes[n].get('kind', '')}
        if not via_coords:
            # Fallback to any node position if no vias found
            all_coords = {self.G.nodes[n]["xy"][coord_idx] for n in self.G.nodes()}
            return min(all_coords, key=lambda c: abs(c - target_coord))
        return min(via_coords, key=lambda c: abs(c - target_coord))

    def _validate_connectivity(self, partitions: List[Partition], separators: Set) -> bool:
        """Ensure each partition interior forms a single connected component (excluding separators & pads)."""
        from collections import deque
        for p in partitions:
            interior = p.interior_nodes - separators - self.pad_nodes
            if len(interior) <= 1:
                continue
            start = next(iter(interior))
            visited = {start}
            q = deque([start])
            while q:
                cur = q.popleft()
                for nbr in self.G.neighbors(cur):
                    if nbr in visited or nbr in separators or nbr in self.pad_nodes:
                        continue
                    if nbr in interior:
                        visited.add(nbr)
                        q.append(nbr)
            if visited != interior:
                return False
        return True
    
    def _get_connectivity_summary(self, partitions: List[Partition], separators: Set) -> Dict:
        """Analyze connectivity issues and return summary.
        
        Returns dict with:
            - has_isolated_loads: bool, True if any 1-node load components exist
            - num_isolated_loads: int, count of isolated load nodes
        """
        num_isolated = 0
        
        for p in partitions:
            interior = p.interior_nodes - separators - self.pad_nodes
            if len(interior) <= 1:
                continue
            
            # Find all components
            components = self._find_connected_components(interior, separators)
            
            # Count 1-node components that are loads
            for comp in components:
                if len(comp) == 1:
                    node = next(iter(comp))
                    if node in self.load_nodes:
                        num_isolated += 1
        
        return {
            'has_isolated_loads': num_isolated > 0,
            'num_isolated_loads': num_isolated
        }
    
    # (Legacy k-means helpers removed.)
    
    def _find_connected_components(
        self,
        nodes: Set,
        separator_nodes: Set
    ) -> List[Set]:
        """Find all connected components within a set of nodes without crossing separators.
        
        Args:
            nodes: Set of nodes to analyze
            separator_nodes: Nodes that cannot be traversed
        
        Returns:
            List of connected component sets
        """
        from collections import deque
        
        unvisited = nodes.copy()
        components = []
        
        while unvisited:
            # Start a new component
            start = next(iter(unvisited))
            component = set()
            queue = deque([start])
            unvisited.remove(start)
            component.add(start)
            
            # BFS to find all nodes in this component
            while queue:
                current = queue.popleft()
                
                for neighbor in self.G.neighbors(current):
                    # Skip if not in our node set
                    if neighbor not in nodes:
                        continue
                    
                    # Skip if already visited
                    if neighbor not in unvisited:
                        continue
                    
                    # Skip separators
                    if neighbor in separator_nodes:
                        continue
                    
                    # Skip pads
                    if neighbor in self.pad_nodes:
                        continue
                    
                    unvisited.remove(neighbor)
                    component.add(neighbor)
                    queue.append(neighbor)
            
            components.append(component)
        
        return components
    
    def _build_partitions(
        self, 
        partition_assignments: Dict,
        separator_nodes: Set,
        P: int
    ) -> List[Partition]:
        """Build Partition objects from assignments and separators."""
        partitions = []
        
        for p in range(P):
            # Collect all nodes in this partition
            partition_nodes = {n for n, pid in partition_assignments.items() if pid == p}
            
            # Separate into interior and separator nodes
            sep_in_partition = partition_nodes & separator_nodes
            interior = partition_nodes - separator_nodes
            
            # Find load nodes in this partition
            loads_in_partition = interior & self.load_nodes
            
            partitions.append(Partition(
                partition_id=p,
                interior_nodes=interior,
                separator_nodes=sep_in_partition,
                load_nodes=loads_in_partition
            ))
        
        return partitions
    
    def _identify_boundary_edges(
        self, 
        separator_nodes: Set
    ) -> List[Tuple]:
        """Identify edges that connect to separator nodes (boundary edges).
        
        Returns:
            List of boundary edges (u, v, edge_data)
        """
        boundary_edges = []
        
        for u, v, data in self.G.edges(data=True):
            # An edge is a boundary edge if at least one endpoint is a separator
            if u in separator_nodes or v in separator_nodes:
                boundary_edges.append((u, v, data))
        
        return boundary_edges
    
    def visualize_partitions(
        self, 
        result: PartitionResult,
        figsize: Tuple[float, float] = (10, 8),
        show: bool = True
    ):
        """Visualize the partitioned grid.
        
        Args:
            result: PartitionResult from partition()
            figsize: Figure size
            show: If True, call plt.show()
        """
        import matplotlib.pyplot as plt
        from matplotlib.colors import ListedColormap
        
        fig, ax = plt.subplots(figsize=figsize)
        
        # Draw all edges (graph is not modified)
        for u, v in self.G.edges():
            x1, y1 = self.G.nodes[u]['xy']
            x2, y2 = self.G.nodes[v]['xy']
            
            # Check if this is a boundary edge
            is_boundary = (u in result.separator_nodes or v in result.separator_nodes)
            
            if is_boundary:
                # Draw boundary edges in red/dashed
                ax.plot([x1, x2], [y1, y2], 'r--', lw=1.0, alpha=0.5, zorder=2)
            else:
                # Draw interior edges in black
                ax.plot([x1, x2], [y1, y2], 'k-', lw=0.5, alpha=0.3, zorder=1)
        
        # Color palette for partitions
        colors = plt.cm.tab10(np.linspace(0, 1, result.num_partitions))
        
        # Draw nodes by partition
        for partition in result.partitions:
            color = colors[partition.partition_id]
            
            # Interior nodes
            for node in partition.interior_nodes:
                x, y = self.G.nodes[node]['xy']
                if node in partition.load_nodes:
                    ax.scatter(x, y, c=[color], s=80, marker='o', 
                             edgecolors='black', linewidths=1, zorder=4,
                             label=f'P{partition.partition_id} load' if node == list(partition.load_nodes)[0] else '')
                else:
                    ax.scatter(x, y, c=[color], s=30, marker='o', 
                             edgecolors='none', alpha=0.6, zorder=3)
        
        # Draw separator nodes (shared boundary nodes)
        for node in result.separator_nodes:
            x, y = self.G.nodes[node]['xy']
            ax.scatter(x, y, c='white', s=50, marker='s', 
                     edgecolors='red', linewidths=2, zorder=5)
        
        # Draw pads
        for node in self.pad_nodes:
            x, y = self.G.nodes[node]['xy']
            ax.scatter(x, y, c='gold', s=100, marker='*', 
                     edgecolors='black', linewidths=1.5, zorder=6)
        
        ax.set_aspect('equal')
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_title(f'Grid Partitioning (P={result.num_partitions}, '
                    f'Balance={result.load_balance_ratio:.3f})')
        
        # Custom legend
        from matplotlib.patches import Patch
        from matplotlib.lines import Line2D
        legend_elements = [
            Line2D([0], [0], color='r', linestyle='--', lw=2, 
                   label=f'Boundary edges ({len(result.boundary_edges)})'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor='white',
                   markeredgecolor='red', markeredgewidth=2, markersize=8,
                   label=f'Separators ({len(result.separator_nodes)})', linestyle='None'),
            Line2D([0], [0], marker='*', color='w', markerfacecolor='gold',
                   markeredgecolor='black', markeredgewidth=1.5, markersize=12,
                   label=f'Pads ({len(self.pad_nodes)})', linestyle='None'),
        ]
        ax.legend(handles=legend_elements, loc='best')
        
        plt.tight_layout()
        if show:
            plt.show()
            
        return fig, ax
